name: Build and Test Project 1

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  copy_tests:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Compile copy.c using default GCC
        run: |
          gcc -o copy copy.c

      - name: Test copy normal file
        run: |
          # 원본 파일 생성
          echo "GitHub Actions 테스트 파일" > source.txt
          # copy 실행: source.txt를 복사하여 dest.txt로 생성
          ./copy source.txt dest.txt
          # 결과 검증
          diff source.txt dest.txt || { echo 'Copy test failed: source.txt and dest.txt differ'; exit 1; }
          # 정리
          rm source.txt dest.txt

      - name: Test copy empty file
        run: |
          # 빈 파일 생성
          touch empty.txt
          # copy 실행: 빈 파일 복사
          ./copy empty.txt empty_copy.txt
          # 결과 검증
          diff empty.txt empty_copy.txt || { echo 'Copy test failed: empty file copy did not match'; exit 1; }
          # 정리
          rm empty.txt empty_copy.txt

      - name: Test copy binary file
        run: |
          # 1MB 크기의 바이너리 파일 생성
          head -c 1048576 /dev/urandom > binary_source.bin
          # copy 실행: 바이너리 파일 복사
          ./copy binary_source.bin binary_dest.bin
          # 결과 검증
          diff binary_source.bin binary_dest.bin || { echo 'Copy test failed: binary file copy did not match'; exit 1; }
          # 정리
          rm binary_source.bin binary_dest.bin

      - name: Test copy with non-existent source
        run: |
          # 존재하지 않는 소스 파일로 copy 실행, 실패가 예상됨
          ./copy non_existent.txt dest.txt && { echo 'Copy test failed: expected failure on non-existent source'; exit 1; } || echo "Expected failure occurred."

  merge_tests:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Compile merge.c using default GCC
        run: |
          gcc -o merge merge.c

      - name: Prepare test input and run merge
        run: |
          # 첫 번째 입력 파일 생성
          echo "Hello from file 1" > file1.txt
          # 두 번째 입력 파일 생성
          echo "Hello from file 2" > file2.txt
          # merge 실행: output.txt에 file1.txt와 file2.txt 병합 결과 저장
          ./merge output.txt file1.txt file2.txt

      - name: Validate output using diff
        run: |
          # 두 입력 파일을 순서대로 연결한 expected.txt 파일 생성
          cat file1.txt file2.txt > expected.txt
          # 출력 결과와 expected.txt 파일을 비교, 차이가 있으면 실패
          diff expected.txt output.txt || { echo 'Merge test failed: output.txt does not match expected.txt'; exit 1; }

      - name: Validate output file size
        run: |
          size1=$(stat -c %s file1.txt)
          size2=$(stat -c %s file2.txt)
          total=$((size1+size2))
          out_size=$(stat -c %s output.txt)
          if [ "$out_size" -ne "$total" ]; then
            echo "Merge test failed: output.txt size ($out_size) does not equal sum of file1.txt ($size1) and file2.txt ($size2)"
            exit 1
          else
            echo "Output file size verification succeeded."
          fi

  read_tests:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Compile read.c using default GCC
        run: |
          gcc -o read read.c

      - name: Test read functionality
        run: |
          # 테스트용 파일 생성: 알파벳 소문자 26자를 포함하는 파일 생성
          echo "abcdefghijklmnopqrstuvwxyz" > test.txt
          
          # 테스트 1: 오프셋 5, 바이트 수 10 (예상 결과: "fghijklmno")
          expected_output=$(echo -n "fghijklmno")
          output=$(./read 5 10 test.txt)
          if [ "$output" != "$expected_output" ]; then
            echo "테스트 1 실패: 예상 결과 '$expected_output', 실제 결과 '$output'"
            exit 1
          fi
          
          # 테스트 2: 바이트 수 0인 경우 (출력은 빈 문자열)
          output=$(./read 5 0 test.txt)
          if [ -n "$output" ]; then
            echo "테스트 2 실패: 바이트 수가 0이면 출력이 없어야 함. 실제 결과 '$output'"
            exit 1
          fi
          
          # 테스트 3: 남은 바이트보다 큰 요청 - 오프셋 20, 바이트 수 10 (예상 결과: "uvwxyz")
          expected_output=$(echo -n "uvwxyz")
          output=$(./read 20 10 test.txt)
          if [ "$output" != "$expected_output" ]; then
            echo "테스트 3 실패: 예상 결과 '$expected_output', 실제 결과 '$output'"
            exit 1
          fi
          
          # 테스트 4: 오프셋이 파일 크기와 같은 경우 (출력은 빈 문자열)
          file_length=$(stat -c %s test.txt)
          output=$(./read $file_length 10 test.txt)
          if [ -n "$output" ]; then
            echo "테스트 4 실패: 파일 크기와 동일한 오프셋이면 출력이 없어야 함. 실제 결과 '$output'"
            exit 1
          fi
          
          echo "모든 read.c 테스트가 통과되었습니다."

  write_tests:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Compile write.c using default GCC
        run: |
          gcc -o write write.c

      - name: Run write tests
        run: |
          # Test Case 1: Offset within file boundaries
          echo "abcdefghij" > write1.txt
          ./write 5 "XYZ" write1.txt
          echo "abcdeXYZfghij" > expected_write1.txt
          diff expected_write1.txt write1.txt || { echo 'Write test 1 failed'; exit 1; }

          # Test Case 2: Offset equals file length (append at EOF)
          echo "hello" > write2.txt
          ./write 5 " world" write2.txt
          echo "hello world" > expected_write2.txt
          diff expected_write2.txt write2.txt || { echo 'Write test 2 failed'; exit 1; }

          # Test Case 3: Offset in the middle with data longer than the remaining part (extending file)
          echo "12345" > write3.txt
          ./write 3 "ABCDE" write3.txt
          echo "123ABCDE45" > expected_write3.txt
          diff expected_write3.txt write3.txt || { echo 'Write test 3 failed'; exit 1; }

          # Test Case 4: Offset 0 (overwrite beginning of the file)
          echo "abcdef" > write4.txt
          ./write 0 "NEW" write4.txt
          echo "NEWadcdef" > expected_write4.txt
          diff expected_write4.txt write4.txt || { echo 'Write test 4 failed'; exit 1; }

          # Test Case 5: Offset in the middle causing file extension
          echo "0123456" > write5.txt
          ./write 4 "XYZW" write5.txt
          echo "0123XYZW456" > expected_write5.txt
          diff expected_write5.txt write5.txt || { echo 'Write test 5 failed'; exit 1; }

#  insert_tests:
#    runs-on: ubuntu-22.04
#    steps:
#      - name: Checkout repository
#        uses: actions/checkout@v3
#
#      - name: Compile insert.c using default GCC
#        run: |
#          gcc -o insert insert.c
#
#      - name: Prepare test input and run insert
#        run: |
#          echo "abcdefghij" > insert.txt
#          ./insert 7 "XYZ" insert.txt
#
#      - name: Validate insert output using diff
#        run: |
#          echo "abcdefghXYZij" > expected_insert.txt
#          diff expected_insert.txt insert.txt || { echo 'Insert test failed: insert.txt does not match expected content'; exit 1; }
#
#  delete_tests:
#    runs-on: ubuntu-22.04
#    steps:
#      - name: Checkout repository
#        uses: actions/checkout@v3
#
#      - name: Compile delete.c using default GCC
#        run: |
#          gcc -o delete delete.c
#
#      - name: Prepare test input and run delete
#        run: |
#          echo "0123456789" > delete.txt
#          ./delete 3 4 delete.txt
#
#      - name: Validate delete output using diff
#        run: |
#          echo "012789" > expected_delete.txt
#          diff expected_delete.txt delete.txt || { echo 'Delete test failed: delete.txt does not match expected content'; exit 1; }